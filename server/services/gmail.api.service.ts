import type { RuntimeConfig } from 'nuxt/schema'
import { OAuth2Client } from 'google-auth-library'
import { google } from 'googleapis'

import type { Logger } from 'pino'
import type { IGmailApiService } from '~/server/interfaces/services'
import {
  ApiSendEmailError, ApplicationError, GetNewAccessTokenError, InitializeGmailError, OAuthInitializationError,
} from '~/server/errors/custom-errors'

export class GmailApiService implements IGmailApiService {
  private auth: OAuth2Client | undefined
  private readonly config: RuntimeConfig

  constructor(private readonly logger: Logger) {
    this.config = useRuntimeConfig()
  }

  private initializeAuth(): OAuth2Client {
    if (!this.auth) {
      return this.newAuth()
    }
    return this.auth
  }

  /**
   * Prepare the OAuthClient with credentials from .env and
   * generated from Google Cloud
   */
  private newAuth() {
    try {
      this.auth = new OAuth2Client(
        this.config.private.clientID,
        this.config.private.clientSecret,
        this.config.private.redirectUri,
      )
      return this.auth
    }
    catch (e) {
      throw new OAuthInitializationError(`Error initializing OAuth2Client: ${(e as Error).message}`)
    }
  }

  /**
   * Before send email
   * @private
   */
  private async initializeGmail() {
    if (this.auth) {
      return google.gmail({
        version: 'v1',
        auth: this.auth,
      })
    }
    throw new InitializeGmailError('OAuth2Client is not initialized')
  }

  /**
   * Generate OAuth identification link used for generating a code
   * used to receive the refresh_token
   */
  async getAuthUrl(): Promise<string> {
    const auth = this.initializeAuth()
    return auth.generateAuthUrl({
      access_type: 'offline',
      prompt: 'consent',
      scope: [this.config.private.apiScope],
    })
  }

  /**
   * Enable first refresh_token with the code generated by the identification URL
   * @param code
   */
  async getFirstAccessToken(code: string) {
    try {
      // If first connection with code received by getUrl
      const auth = this.initializeAuth()
      const { tokens } = await auth.getToken(code)
      console.log('CREDENTIALS =>', tokens)
      return tokens
    }
    catch (error) {
      console.error('Error retrieving access token', error)
      return undefined
    }
  }

  /**
   * Recovering new access_token with google-auth libraries
   * @param refreshToken
   */
  async getNewToken(refreshToken: string) {
    try {
      const auth = this.initializeAuth()
      // Set identifier in the authenticate object
      auth.setCredentials({ refresh_token: refreshToken })

      const { credentials } = await auth.refreshAccessToken() // Request send

      return credentials
    }
    catch (err) {
      if (err instanceof ApplicationError) {
        throw err
      }
      const error = err as Error
      throw new GetNewAccessTokenError(error.message, { context: error })
    }
  }

  /**
   * Send the email by the Google Gmail API
   * @param encodedEmail
   * @param access_token
   * @return
   */
  async send(encodedEmail: string, access_token: string): Promise<{ success: boolean, message: string }> {
    try {
      const auth = this.initializeAuth()

      auth.setCredentials({ access_token })

      const gmail = await this.initializeGmail()

      return await gmail.users.messages.send({
        userId: 'me',
        requestBody: { raw: encodedEmail },
      })
        .then((result) => {
          const message = `Email successfully sent, Date => ${result.data.internalDate}`

          this.logger.info(message)
          return { success: true, message: message }
        })
        .catch((error) => {
          throw new ApiSendEmailError(`Unable to send email : ${error.message}`, error)
        })
    }
    catch (err) {
      if (err instanceof ApplicationError) {
        throw err
      }
      else {
        throw new ApiSendEmailError(`Can't send email, exception generate before request API: ${(err as Error).message}`, { error: err })
      }
    }
  }
}
